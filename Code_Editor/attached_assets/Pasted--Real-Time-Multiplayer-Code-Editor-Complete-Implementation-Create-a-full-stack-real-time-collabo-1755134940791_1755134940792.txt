# Real-Time Multiplayer Code Editor - Complete Implementation

Create a full-stack real-time collaborative code editor with the following exact specifications:

## Tech Stack
- **Frontend**: React with Monaco Editor integration
- **Backend**: Node.js with Express and Socket.io
- **Database**: MongoDB for persistence
- **Real-time**: Socket.io for WebSocket connections

## Core Features Required

### 1. Real-Time Collaborative Editing
- Multiple users can edit the same document simultaneously
- Changes propagate instantly to all connected clients
- Operational Transform (OT) or Conflict-Free Replicated Data Types (CRDT) for conflict resolution
- No character loss or duplication during simultaneous edits

### 2. User Presence & Awareness
- Show active collaborators list with unique colors
- Display real-time cursor positions for each user
- Show text selections/highlights for each user
- User join/leave notifications

### 3. Data Persistence
- Auto-save all changes to SQLite database
- Restore document state on page refresh
- Handle reconnections gracefully with state sync
- Version history tracking (basic)

## File Structure
```
/
├── server.js (Express + Socket.io server)
├── package.json
├── client/
│   ├── src/
│   │   ├── App.js
│   │   ├── components/
│   │   │   ├── CodeEditor.js
│   │   │   ├── UserList.js
│   │   │   ├── ConnectionStatus.js
│   │   │   └── CursorOverlay.js
│   │   ├── hooks/
│   │   │   ├── useSocket.js
│   │   │   └── useCollaborativeEditor.js
│   │   ├── utils/
│   │   │   └── operationalTransform.js
│   │   └── index.js
│   ├── public/
│   │   └── index.html
│   └── package.json
└── models/
    ├── Document.js
    └── DocumentVersion.js
```

## Implementation Requirements

### Server.js Features:
- Express server with CORS enabled for React frontend
- Socket.io integration for real-time communication
- MongoDB connection using Mongoose
- Document state management and conflict resolution
- User session tracking with MongoDB
- Broadcast changes to all connected clients except sender
- Handle user disconnect/reconnect scenarios
- Serve React build files in production

### Frontend Features (React Components):
- **App.js**: Main application container with Socket.io provider
- **CodeEditor.js**: Monaco Editor integration with operational transform
- **UserList.js**: Display active collaborators with colored indicators  
- **ConnectionStatus.js**: Show connection state and reconnection logic
- **CursorOverlay.js**: Real-time cursor and selection visualization
- **useSocket.js**: Custom hook for Socket.io connection management
- **useCollaborativeEditor.js**: Custom hook for collaborative editing logic
- Auto-reconnection logic with exponential backoff
- Debounced saving (300ms delay)
- Real-time text synchronization with conflict resolution

### Database Schema (MongoDB Collections):
```javascript
// Documents Collection
{
  _id: ObjectId,
  title: String,
  content: String,
  lastModified: Date,
  createdAt: Date,
  activeUsers: [String], // Array of user IDs currently editing
}

// DocumentVersions Collection  
{
  _id: ObjectId,
  documentId: ObjectId,
  content: String,
  version: Number,
  timestamp: Date,
  operations: [Object], // Array of operational transform operations
}

// Users Collection (for session tracking)
{
  _id: ObjectId,
  sessionId: String,
  username: String,
  color: String, // Hex color for cursor/selection
  lastSeen: Date,
  currentDocument: ObjectId,
}
```

## Key Technical Implementation Details

### Conflict Resolution Strategy:
Use Operational Transform with these operation types:
- INSERT: Insert text at position
- DELETE: Delete text from position with length
- RETAIN: Keep existing text (for cursor positioning)

### Socket.io Events to Implement:
- `user-joined`: New user connection
- `user-left`: User disconnection  
- `text-change`: Text modification with operation details
- `cursor-position`: Cursor movement
- `text-selection`: Text selection changes
- `request-sync`: Full document state request
- `document-sync`: Full document state response

### Error Handling Requirements:
- Network disconnection recovery
- Database connection failures
- Malformed operation handling
- Rate limiting for operations (prevent spam)
- Input validation and sanitization

### Performance Optimizations:
- Debounce text changes before sending
- Compress large operations
- Limit history to last 100 versions
- Clean up disconnected user data after 30 seconds

## UI/UX Requirements

### Layout:
- Split view: Code editor (80%) + User panel (20%)
- Top bar with connection status and document title
- User avatars with colored borders matching cursor colors
- Status messages for user join/leave events

### Styling Guidelines:
- Modern, clean interface similar to VS Code
- Dark theme as default
- Smooth animations for cursor movements
- Responsive design for different screen sizes
- Loading states and error messages

## Code Quality Requirements:
- React best practices with functional components and hooks
- Comprehensive error handling with try-catch blocks and Error Boundaries
- Input validation and sanitization on both client and server
- Rate limiting (max 50 operations per second per user)
- Clean, commented code with consistent formatting
- No console.log statements in production code
- Proper cleanup in useEffect hooks to prevent memory leaks
- TypeScript-style prop validation with PropTypes
- MongoDB connection pooling and proper error handling

## Testing Scenarios to Handle:
- Multiple users typing simultaneously at same position
- User disconnects mid-edit and reconnects
- Very rapid typing and operations
- Large document handling (>10,000 lines)
- Network lag simulation
- Browser refresh during active editing

## Security Measures:
- Sanitize all user input
- Rate limiting on socket connections
- Basic XSS protection
- Input length limits (max 1MB document size)

## Performance Targets:
- <50ms latency for local operations
- <200ms for remote operation propagation
- Support up to 10 simultaneous users
- Handle documents up to 10,000 lines efficiently

Please generate complete, production-ready code for all files with proper error handling, optimization, and the exact functionality described above. The code should work immediately when deployed to Replit without requiring additional setup or debugging.